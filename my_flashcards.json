{
    "title": "My Flashcards",
    "cards": [
      {
        "question": "What is a database?",
        "answer": "A database is an organized set of stored data that can be accessed from a computer."
      },
      {
        "question": "What is a DBMS?",
        "answer": "A DataBase Management System is a software system designed to manipulate, add, retrieve, define, and manage data in a database."
      },
      {
        "question": "What is the difference bewteen an RDBMS and a DBMS?",
        "answer": "A Relational DataBase Management System stores data in a collection of tables where relations can be defined using the common fields (columns) of the tables."
      },
      {
        "question": "What is SQL?",
        "answer": "Structured Query Language is a programming language for manipulating, adding, and retrieving data stored in a relational database."
      },
      {
        "question": "What are tables is SQL?",
        "answer": "A table is composed of rows (records) and columns (fields) in which data is stored in an organized way."
      },
      {
        "question": "What are constraints in SQL?",
        "answer": "Constraints are rules that dictate the type of data that can go into a table or column (field). If there is any violation between the constraint and the data action, the action is aborted."
      },
      {
        "question": "Give examples of constraints commonly used in SQL.",
        "answer": "NOT NULL: Ensures that a column cannot have a NULL value. UNIQUE: Ensures that all values in a column are different. PRIMARY KEY: Uniquely identifies each row in a table. FOREIGN KEY: Prevents invalid data from being inserted into the foreign key column, because it has to be one of the values contained in the parent table. CHECK: Ensures that the values in a column satisfies a specific condition. DEFAULT: Sets a default value for a column if no value is specified."
      },
      {
        "question": "What is a primary key in SQL?",
        "answer": "A primary key uniquely identifies each row in a table. It also has an implicit NOT NULL constraint."
      },
      {
        "question": "What is a foreign key in SQL?",
        "answer": "A foreign key is a link between tables. An attribute/collection of attributes in a table that refer to the primary key of another table."
      },
      {
        "question": "What is a JOIN in SQL?",
        "answer": "A JOIN clause combines records (rows) from one or more tables based on a related column between the two into a new table."
      },
      {
        "question": "What are the types of JOINs in SQL?",
        "answer": "INNER JOIN: Returns records that have matching values in both tables. LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table. RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table. FULL (OUTER) JOIN: Returns all records when there is a match in either left or right table."
      },
      {
        "question": "What is a SELF-JOIN (unary relation) in SQL?",
        "answer": "A SELF-JOIN (unary relation) is a regular join, but the table is joined with itself."
      },
      {
        "question": "What is an index in SQL?",
        "answer": "An index is a quick lookup table for finding records very fast. Indexes should only be created on columns that will be frequently searched against because updating a table with indexes takes more time than updating a table with no indexes (since the indexes also need to be updated)."
      },
      {
        "question": "What are the differences between clustered and non-clustered indexes in SQL?",
        "answer": "CLUSTERED INDEX: Determines the physical order of data in the table. Each table can have only one clustered index. Provides faster data retrieval for the indexed column(s). May result in slower data modification operations (INSERT, UPDATE) due to the need to maintain the order. NON-CLUSTERED INDEX: Doesn't change the physical order of data in the table. Allows multiple non-clustered indexes per table. Results in slower data retrieval compared to a clustered index for indexed columns. Offers faster data modification operations compared to clustered indexes."
      },
      {
        "question": "What is abstraction in C#?",
        "answer": "Abstraction is hiding the unnecessary details from type consumers."
      },
      {
        "question": "What is encapsulation in C#?",
        "answer": "Encapsulation means that a group of related properties, methods, and other members are treated as a single unit or object. An example would be using access modifiers on class members (public, private, protected, etc.)."
      },
      {
        "question": "What is inheritance in C#?",
        "answer": "Inheritance describes the ability to create new classes based on an existing class by acquiring the its members."
      },
      {
        "question": "What is polymorphism in C#?",
        "answer": "Polymorphism means that you can have multiple classes that can be used interchangeably, even though each class implements the same properties or methods in different ways. Polymorphism means that a call to a member method will cause a different implementation to be executed depending on the type of object that invokes the method. Typically, polymorphism occurs when there is a hierarchy of classes and they are related through inheritance from a common base class."
      },
      {
        "question": "List and define the different possible forms of accessibility for class members in C#.",
        "answer": "PUBLIC: The type or member can be accessed by any other code in the same assembly or another assembly that references it. PROTECTED: The type or member can only be accessed by code in the same class or struct, or in a derived class. INTERNAL: The type or member can be accessed by any code in the same assembly, but not from another assembly. PROTECTED INTERNAL: The type or member can be accessed by any code in the same assembly, or by any derived class in another assembly. PRIVATE: The type or member can only be accessed by code in the same class or struct. SEALED: Cannot be inherited."
      },
      {
        "question": "What is the difference between a class and an object in C#?",
        "answer": "Objects are instances of classes."
      },
      {
        "question": "What does the `this` keyword mean in C#?",
        "answer": "The `this` keyword is a reference to the current instance of a class."
      },
      {
        "question": "Describe the garbage collection process in .NET.",
        "answer": "The .NET Framework has a garbage collector that periodically releases memory used by objects when they are no longer accessible. An object will be eligible for destruction when there are no more references to it. Note: Objects cannot be explicitly deallocated in C#."
      },
      {
        "question": "What is the difference between an abstract class and an interface in C#?",
        "answer": "An abstract class is a class that cannot be instantiated. Instead, it serves as a base class for other classes to inherit from. Abstract classes are used to define a common set of behaviors or properties that derived classes should have. Interfaces specify what a class must do and not how. Like a class, Interface can have methods, properties, events, and indexers as its members. But interfaces will contain only the declaration of the members."
      },
      {
        "question": "What does the modifier `static` indicate in C#?",
        "answer": "You cannot instantiate an object of a static class, as only one instance of the static class can exist in a program. A `static` property is available to callers at any time, even if no instance of the class exists. "
      },
      {
        "question": "Explain the differences between Singleton, Scoped, and Transient lifetimes in ASP.NET Core Web API.",
        "answer": "SINGLETON: Objects registered as singletons are created once and shared throughout the application's lifetime. This is useful for stateless services or objects that are expensive to create and can be reused across requests. SCOPED: Scoped objects are created once per client request within the scope of that request. They are disposed of when the request ends. Scoped lifetime is beneficial for objects that maintain state specific to a single request, such as database contexts or unit of work instances. TRANSIENT: Transient objects are created every time they are requested. They are not shared between requests or other components. Transient lifetime is suitable for lightweight, stateless services where a new instance is needed for each operation."
      },
      {
        "question": "What is metadata?",
        "answer": "Metadata describes every type and member defined in our code in a multi-language form. Metadata stores the following information: 1. description of assembly, 2. identity (name, version, culture, public key), 3. the types that are exported, 4. other assemblies that this assembly depends on, and 5. security permissions are needed to run."
      },
      {
        "question": "What is an assembly?",
        "answer": "Assemblies are the building block of .NET framework applications; they form the fundamental unit of deployment, version control, reuse, activation scoping and security permissions."
      },
      {
        "question": "What is C#?",
        "answer": "C# is a Simple, Secure, Robust, Portable, Platform-Independent, Architectural Neutral, Multithreaded, Automatic Memory Management, Object-Oriented Programming Language with a strong type Exception Handling mechanism for developing different kinds of applications such as Web, Windows Form, Console, Web Services, Mobile Apps, etc. which can be run on different Operating Systems such as Windows, Linus, and Mac."
      },
      {
        "question": "What is the difference between an EXE and a DLL?",
        "answer": "An EXE is an executable file and can run by itself as an application whereas DLL is usually consumed by an EXE or by another DLL and we cannot run or execute DLL directly. For example in .NET compiling a Console Application or a Windows Application generates EXE, whereas compiling a Class Library Project or an ASP.NET web application generates DLL. In the .NET framework, both EXE and DLL are called assemblies. A DLL can be reused in the application whereas an exe file can never be reused in an application. EXE stands for executable, and DLL stands for Dynamic Link Library."
      },
      {
        "question": "What do you mean by String objects are immutable?",
        "answer": "String objects cannot be changed once they are created. All of the String methods and C# operators that appear to modify a string actually return the results in a new string object."
      },
      {
        "question": "How do you determine whether a String represents a numeric value?",
        "answer": "To determine whether a String represents a numeric value, we can use the TryParse method as shown in the example below. If the string contains non-numeric characters or the numeric value is too large or too small for the particular type you have specified, TryParse returns false and sets the out parameter to zero. Otherwise, it returns true and sets the out parameter to the numeric value of the string."
      },
      {
        "question": "What are Properties in C#?",
        "answer": "Properties in C# are class members that provide a flexible mechanism to read, write, or compute the values of private fields. Properties can be used as if they are public data members, but they are actually special methods called accessors. This enables data to be accessed easily and still helps promote the safety and flexibility of methods."
      },
      {
        "question": "What are the different types of properties available in C#?",
        "answer": "READ-ONLY: Properties without a set accessor are considered read-only. WRITE-ONLY: Properties without a get accessor are considered write-only. READ-WRITE: Properties with both a get and set accessor are considered read-write properties."
      },
      {
        "question": "What are the advantages of using properties in C#?",
        "answer": "1. Properties can validate data before allowing a change. 2. It can transparently expose data on a class where that data is actually retrieved from some other source such as a database. 3. Properties can take action when data is changed, such as raising an event or changing the value of other fields."
      },
      {
        "question": "What is Virtual Property in C#?",
        "answer": "Virtual properties enable derived classes to override the property behavior by using the override keyword."
      },
      {
        "question": "What is an Abstract Property in C#?",
        "answer": "An abstract property should not have any implementation in the class. The derived classes must write their own implementation."
      },
      {
        "question": "What are the 2 types of data types available in C#?",
        "answer": "1. Value Types 2. Reference Types"
      },
      {
        "question": "If you define a user-defined data type by using the struct keyword, Is it a value type or reference type?",
        "answer": "Value Type"
      },
      {
        "question": "If you define a user-defined data type by using the class keyword, Is it a value type or reference type?",
        "answer": "Reference Type"
      },
      {
        "question": "Give examples of value types.",
        "answer": "Enums and Structs"
      },
      {
        "question": "Give examples for reference types.",
        "answer": "Classes, Delegates, Arrays, and Interfaces"
      },
      {
        "question": "What are the differences between value types and reference types?",
        "answer": "Value types are stored on the stack whereas reference types are stored on the managed heap. The Value type variables directly contain their values whereas reference variables hold only a reference to the location of the object that is created on the managed heap. There is no heap allocation or garbage collection overhead for value-type variables. As reference types are stored on the managed heap, they have the overhead of object allocation and garbage collection. Value Types cannot inherit from another class or struct. Value types can only inherit from interfaces. Reference types can inherit from another class or interface."
      },
      {
        "question": "What are the 2 kinds of data type conversions available in C#?",
        "answer": "1. Implicit conversions: No special syntax is required because the conversion is typesafe and no data will be lost. Examples include conversions from smaller to larger integral types and conversions from derived classes to base classes. 2. Explicit conversions: Explicit conversions require a cast operator. The source and destination variables are compatible, but there is a risk of data loss because the type of the destination variable is a smaller size than (or is a base class of) the source variable."
      },
      {
        "question": "What is the difference between an implicit conversion and an explicit conversion?",
        "answer": "Explicit conversions require a cast operator whereas an implicit conversion is done automatically. The Explicit conversion can lead to data loss whereas with implicit conversions there is no data loss."
      },
      {
        "question": "What do protected internal access modifiers mean?",
        "answer": "The protected internal access means protected OR internal, not protected, AND internal. In simple terms, a protected internal member is accessible from any class in the same assembly, including derived classes. To limit access to only derived classes in the same assembly, declare the class itself internal, and declare its members as protected."
      },
      {
        "question": "What is the default access modifier for a class, struct, and interface declared directly with a namespace?",
        "answer": "internal"
      },
      {
        "question": "Can you specify an access modifier for an enumeration?",
        "answer": "Enumeration members are always public, and no access modifiers can be specified."
      },
      {
        "question": "Discuss the differences between constants and read-only variables.",
        "answer": "1. Constants are evaluated at compile time, while the read-only variables are evaluated at run time. 2. Constants support only value-type variables (the only exception being strings), while read-only variables can hold reference-type variables. 3. Constants should be used when the value is not changing during run time, and read-only variables are used mostly when their actual value is unknown before run time. 4. Read-only variables can only be initialized at the time of declaration or in a constructor."
      },
      {
        "question": "Why can't you specify access modifiers for items in an interface?",
        "answer": "Interfaces are always public."
      },
      {
        "question": "What is a delegate in .NET?",
        "answer": "A delegate in .NET is similar to a function pointer in C or C++. Using a delegate allows the programmer to encapsulate a reference to a method inside a delegate object. The delegate object can then be passed to code which can call the referenced method, without having to know at compile time which method will be invoked. In addition, we could use delegate to create custom event within a class."
      },
      {
        "question": "Explain the difference between the Stack and the Heap.",
        "answer": "In the Stack are stored value types (types inherited from System.ValueType), and in the Heap are stored reference types (types inherited from System.Object). The Stack is responsible for keeping track of what is actually executing and where each executing thread is (each thread has its own Stack). The Heap, on the other hand, is responsible for keeping track of the data, or more precise objects."
      },
      {
        "question": "Explain what LINQ is.",
        "answer": "LINQ is an acronym for Language Integrated Query, and was introduced with Visual Studio 2008. LINQ is a set of features that extends query capabilities to the .NET language syntax by adding sets of new standard query operators that allow data manipulation, regardless of the data source. Supported data sources are: .NET Framework collections, SQL Server databases, ADO.NET Datasets, XML documents, and any collection of objects that support IEnumerable or the generic IEnumerable<T> interface, in both C# and Visual Basic. In short, LINQ bridges the gap between the world of objects and the world of data."
      },
      {
        "question": "Explain the difference between boxing and unboxing.",
        "answer": "Boxing is the process of converting a value type to the type object, and unboxing is extracting the value type from the object. While the boxing is implicit, unboxing is explicit."
      },
      {
        "question": "Explain the difference between managed and unmanaged code.",
        "answer": "MANAGED CODE is a code created by the .NET compiler. It does not depend on the architecture of the target machine because it is executed by the CLR (Common Language Runtime), and not by the operating system itself. CLR and managed code offers developers few benefits, like garbage collection, type checking and exceptions handling. UNMANAGED CODE is directly compiled to native machine code and depends on the architecture of the target machine. It is executed directly by the operating system. In the unmanaged code, the developer has to make sure he is dealing with memory usage and allocation (especially because of memory leaks), type safety and exceptions manually."
      },
      {
        "question": "List and explain the execution steps of a .NET application.",
        "answer": "1. The compiler compiles the Source Code into Intermediate Language (IL). 2. The JIT compiler of CLR will convert the Intermediate Language (IL) code into native code (Machine Code or Binary Code), which the underlying operating system can then execute. "
      },
      {
        "question": "What are the different types of .NET Framework?",
        "answer": "1. .NET Framework: .NET Framework is the original implementation of .NET. It supports running websites, services, desktop applications, and more on Windows OS Only. 2. .NET: .NET is a cross-platform implementation for running websites, services, and console applications on Windows, Linux, and macOS. .NET is open source on GitHub and .NET was previously called .NET Core. 3. Xamarin/Mono: Xamarin/Mono is a .NET implementation for running apps on all the major mobile operating systems, including iOS and Android."
      },
      {
        "question": "What is JIT?",
        "answer": "JIT stands for the Just-in-Time compiler. It is the component of CLR that is responsible for converting MSIL code into Native Code. Native code is code that is directly understandable by the operating system."
      },
      {
        "question": "What are the two major components of the .NET Framework",
        "answer": "1. CLR: The Common Language Runtime (CLR) is the execution engine that handles running applications. It provides services like thread management, garbage collection, type safety, exception handling, and more. 2. BCL: The Base Class Library provides a set of APIs and types for common functionality. It provides types for strings, dates, numbers, etc. The Class Library includes APIs for reading and writing files, connecting to databases, drawing, and more."
      },
      {
        "question": "What is the difference between .NET and .NET Framework?",
        "answer": "1. .NET is Cross-Platform and runs on Linux, macOS, and Windows OS. .NET Framework only runs on Windows OS. 2. .NET is Open-Source and accepts contributions from the community. The .NET Framework source code is available but does not take direct contributions. 3. .NET Framework is included in Windows and automatically updated machine-wide by Windows Update. .NET is shipped independently."
      },
      {
        "question": "What are the pros of using C#/.NET?",
        "answer": "1. C# IS SIMPLE AND FAMILIAR: C# is simple because C# simplifies the programmer's job by avoiding certain features of C and C++. C# avoids explicit memory management. Memory management in C# is automatic. It is done by CLR. So, there is no chance of memory leakage. There is a pointer concept in C# but it is restricted. C# is very familiar to programmers because it is modeled on the C and C++ languages. C# uses many features of C and C++; therefore, C# codes look like C and C++ codes. We can say C# is the simplified version of C and C++. 2. C# IS PORTABLE: Portability allows the programmer to write the same code for different machines (operating systems). C# provides portability in two ways: a. Source Code Portability b. IL Code Portability (DLL and EXE). In C#, we can write the source code in Multiple OS and get the output. Even though we can IL Code Portability is also available. So, once you have the DLL and EXE, then you can use those DLLs and EXEs on different OS and you can get the output as expected. Whereas in the case of C and C++ there is only source code portability. 3. C# IS ARCHITECTURALLY NEUTRAL: The behavior of C# programs doesn't change when we move from one system to another which means it will provide the same output in every machine because in C# memory layout decisions are not made at compile time, it is made at run time by CLR. It is because of CTS (Common Type System) and in our coming session we will discuss it in detail. But in the case of C and C++ programs, the behavior changes when we move the program from one system to another and the reason for this is the size of data types varies from OS to OS. 4. C# IS SECURED: C# is secured because the C# programs are executed in a secured environment called CLR. CLR will provide security to the C# programs. 5. C# IS ROBUST: Robust means Strong. C# is a strong type-checking language having strict type-checking during both compilation time and execution time which allows us to develop error-free applications and programs. 6. C# IS DISTRIBUTED: Using C# Programming Language, we can develop distributed applications whose resources are shared by more than one client. An application or program whose resources are shared by more than one client is called a distributed application. As C# is used for developing such applications for example WCF Applications, Restful Services, etc. So, C# is a distributed programming language. 7. C# IS MULTITHREADED: A process is divided into several small parts known as threads or lightweight processes. Sending multiple threads to the processor for processing is known as multithreading. Multi-threading means handling multiple tasks simultaneously. For example, we can listen to music while scrolling a page and at the same time we can download an application from the internet on a computer. If multiple threads are used to execute your application code, then it is called Multithreading. Multithreading is a mechanism to implement Concurrent Programming where multiple threads execute the code simultaneously. And using C# Programming language we can develop multithread applications. So, C# supports multithreaded programming. 8. C# IS DYNAMIC: C# 4.0 introduced a new type called dynamic that avoids compile-time type checking. A dynamic type escapes type checking at compile-time; instead, it resolves the type at run time. So, if you don't know the type of data that you want to store, then you can use dynamic as the data type, and at runtime based on value or data, the type will automatically resolve. So, C# is dynamic. 9. C# IS COMPILED AND INTERPRETED: We know a programming language is either compiled or interpreted. But C# combines both approaches. That's why C# is called a two-stage system. First C# compiler CSC translates source code into an intermediate language code known as MSIL (Microsoft Intermediate Language) or CIL (Common Intermediate Language) code. But these MSIL or CIL or IL codes are not machine instructions. So, in the second stage, these MSIL or CIL, or IL codes are interpreted by the C# interpreter (One Component of CLR called JIT- Just in Time Compiler). As a result, machine instructions will be generated which are directly executed by the machine. Hence, we are saying C# is both interpreted and compiled language. 10. C# IS OBJECT-ORIENTED: Except for the primitive data types, all elements in C# are objects. Object-oriented is not a programming language, it is a programming technique or concept, or principle which defines a set of rules and regulations for organizing the data and instructions. The concepts provided by oops are as follows: a. Encapsulation b. Abstraction c. Polymorphism d. Inheritance. 11. C# IS PLATFORM INDEPENDENT: Many Programming Languages are compatible with only one platform. Now, with the introduction of .NET Core or .NET, C# was specifically designed to be platform-independent. C# applications with .NET Core or .NET can be run on Windows, Linux, and Mac operating systems. So, we can say C# is Platform Independent with .NET Core or .NET. 12. AUTOMATIC MEMORY MANAGEMENT: The .NET Framework automatically manages memory allocation and de-allocation for objects. When a dot net application runs, lots of objects are created. At a given point in time, it is possible that some of those objects are not used by the application. Garbage Collector in .NET Framework is nothing but a Small Routine or you can say it is a Background Process that runs periodically and try to identify what objects are not being used currently by the application and de-allocates the memory of those objects. So, as a developer, we need not worry about how memory allocation and deallocation are done in .NET Applications. 13. EXCEPTION HANDLING: C# Provides Strong Exception Handling Features which can be used to stop the Abnormal Termination of the program and you can also provide user-understandable messages when an exception is raised."
      },
      {
        "question": "What are the features of C#?",
        "answer": "1. SIMPLE: C# is a simple language in the sense that it provides a structured approach (to break the problem into parts), a rich set of library functions, data types, etc. 2. MODERN PROGRAMMING LANGUAGE: C# programming is based upon the current trend and it is very powerful and simple for building scalable, interoperable, and robust applications. 3. OBJECT-ORIENTED: C# is an object-oriented programming language. OOPs makes development and maintenance easier whereas in Procedure-oriented programming language it is not easy to manage if code grows as the project size grows. 4. TYPE-SAFE: C# type safe code can only access the memory location that it has permission to execute. Therefore, it improves the security of the program. 5. INTEROPERABILITY: The interoperability process enables the C# programs to do almost anything that a native C++ application can do. 6. SCALABLE AND UPDATEABLE: C# is an automatic scalable and updateable programming language. For updating our application, we delete the old files and update them with new ones. 7. COMPONENT ORIENTED: C# is a component-oriented programming language. It is the predominant software development methodology used to develop more robust and highly scalable applications. 8. STRUCTURED PROGRAMMING LANGUAGE: C# is a structured programming language in the sense that we can break the program into parts using functions. So, it is easy to understand and modify. 9. RICH LIBRARY: C# provides a lot of inbuilt functions that make development fast. 10. FAST SPEED: The compilation and execution time of the C# language is fast."
      },
      {
        "question": "What are some differences between multithreading, parallel programming, and asynchronous programming in C#?",
        "answer": "1. MULTITHREADING is all about a single process split into multiple threads. 2. PARALLEL PROGRAMMING is all about multiple tasks running on multiple cores simultaneously. 3. ASYNCHRONOUS PROGRAMMING is all about a single thread initiating multiple tasks without waiting for each to complete."
      },
      {
        "question": "What is a class?",
        "answer": "A class is a blueprint or template for creating objects. It encapsulates data (fields) and functionality (methods) into a single unit, providing a way to model real-world entities or concepts in software."
      },
      {
        "question": "How does a class differ from an abstract class?",
        "answer": "An abstract class cannot be instantiated directly, while a regular class can. It can have both abstract and non-abstract (implemented) methods, while a regular class can only have non-abstract methods. A class can inherit from only one abstract class but implement multiple interfaces."
      },
      {
        "question": "How does an abstract class differ from an interface? What are interfaces for, and what tasks do they perform?",
        "answer": "The main differences between an abstract class and an interface are: Abstract classes can have both abstract and non-abstract members. Interfaces can only have abstract members (except for static and extension methods in C# 8.0 and later). Abstract classes can have access modifiers and can provide method implementations. Interfaces can only have public abstract members. A class can inherit from only one abstract class but implement multiple interfaces. Interfaces are used to achieve abstraction and define a contract."
      },
      {
        "question": "What is the difference between regular and static classes?",
        "answer": "A regular class can be instantiated and has both static and instance members. A static class cannot be instantiated and contains only static members. Static classes are useful for providing utility methods or constants that don't require any instance state."
      },
      {
        "question": "What is the difference in method overriding between the keywords new and override",
        "answer": "When overriding a method, the new keyword hides the base class implementation. In contrast, override replaces the base class implementation with the derived class implementation."
      },
      {
        "question": "What is the difference between const and readonly?",
        "answer": "1. const is a compile-time constant. 2. readonly can be set at runtime but cannot be changed after initialization. 3. const values are inlined by the compiler. 4. readonly fields are stored as instance fields."
      },
      {
        "question": "What is asynchronicity, and how does it differ from multithreading?",
        "answer": "Asynchronicity allows a program to perform other tasks while waiting for a long-running operation to complete without blocking the main thread. It is different from multithreading, which involves running multiple threads concurrently. With asynchronicity, the application can continue executing other code while the asynchronous operation is in progress, improving overall responsiveness and efficiency. On the other hand, multithreading involves parallel execution of multiple threads, which can be useful for CPU-bound tasks but requires more complex synchronization and resource management."
      },
      {
        "question": "What do the keywords async/await mean?",
        "answer": "The async keyword marks a method as asynchronous, allowing it to use the await keyword to pause the execution of the method until the awaited asynchronous operation completes. It enables the method to return control to the caller while the asynchronous operation is in progress, improving the application's overall responsiveness."
      },
      {
        "question": "What are the difference between relational and non-relational databases, the pros and cons of using both options.",
        "answer": "RELATIONAL DATABASES (SQL) store data in tables with defined schemas, using a structured query language (SQL) for data manipulation and retrieval. They excel at handling structured data and complex queries. Relational databases are generally stronger regarding data integrity, consistency, and complex querying. NON-RELATIONAL (NoSQL) databases use flexible, schema-less data models, such as key-value, document-oriented, or graph-based. They are better suited for handling unstructured data and high scalability requirements. Non-relational databases offer higher availability, partition tolerance, and scalability."
      },
      {
        "question": "What are indexes in RDBMS?",
        "answer": "Indexes in RDBMS are additional data structures that improve the speed of data retrieval operations, such as SELECT queries. Indexes create a sorted list of values from a table column and pointers to the corresponding rows."
      },
      {
        "question": "What is the fundamental difference between unit tests and integration tests?",
        "answer": "UNIT TESTS focus on testing individual units or components of a system in isolation, verifying that each unit works as expected. They target the smallest testable parts of an application, such as individual methods or classes, and aim to ensure the correctness of the implementation. INTEGRATION TESTS, on the other hand, verify that different components of a system work together correctly. They test the interactions between multiple units or modules, ensuring the overall system functions as expected. Integration tests are typically performed after unit tests, and they help identify issues that may arise from integrating different parts of the application. * The main difference is that unit tests target individual units of code, while integration tests focus on the interactions and data flow between those units. Unit tests are typically easier to write, maintain, and run, while integration tests provide a more comprehensive understanding of the system's behavior."
      },
      {
        "question": "What are unit tests used for?",
        "answer": "Unit tests are used to verify the correctness of individual units of code (methods, classes, or components) in isolation. By testing units in isolation, you ensure each building block functions correctly, leading to a reliable application."
      },
      {
        "question": "What are the advantages and disadvantages of using unit tests?",
        "answer": "Advantages of unit tests include catching bugs early, improving code quality, and providing a safety net for future changes. Disadvantages include additional development effort and the potential for tests to become outdated over time."
      },
      {
        "question": "From what three logical blocks is a unit test composed?",
        "answer": "ARRANGE: Set up the necessary test data and preconditions. ACT: Execute the code being tested. ASSERT: Verify that the observed outcome matches the expected outcome."
      },
      {
        "question": "Describe in as much detail as possible what happens at the HTTP level when you type google.com in a browser.",
        "answer": "1. The browser first resolves the domain name “google.com” to an IP address using the Domain Name System (DNS). The browser sends a DNS query to a DNS server, which looks up the IP address associated with the domain. 2. Once the IP address is obtained, the browser initiates a TCP connection with the web server at that IP address, using the HTTP protocol on port 80 (the default HTTP port). 3. The browser then sends an HTTP GET request to the web server, requesting the root resource (usually the home page). The request includes headers with information about the client, such as the browser type, accepted file types, and other metadata. 4. The web server receives the request, processes it, and generates a response. The response includes an HTTP status code (e.g., 200 for successful, 404 for not found), response headers with metadata about the response, and the web page's actual content (usually in HTML format). 5. The browser receives the response, parses the HTML, and renders the web page. As the page loads, the browser may send additional requests for resources referenced in the HTML, such as images, stylesheets, and JavaScript files. 6. The browser continues to fetch all the necessary resources and assembles the complete web page, displaying it to the user.  * HTTPS (Hypertext Transfer Protocol Secure) is a secure version of the HTTP protocol that adds encryption to the communication between the client (browser) and the web server."
      },
      {
        "question": "What is your understanding of SOLID principles?",
        "answer": "1. SINGLE RESPONSIBILITY PRINCIPLE (SRP): A class should have only one reason to change. 2. OPEN/CLOSED PRINCIPLE (OCP):Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. 3. LISKOV SUBSTITUTION PRINCIPLE (LSP): Subtypes must be substitutable for their base types. 4. Clients should not be forced to depend on interfaces they do not use. 5. DEPENDENCY INVERSION PRINCIPLE (DIP): High-level modules should not depend on low-level modules. Both should depend on abstractions."
      },
      {
        "question": "What is dependency injection?",
        "answer": "Dependency Injection (DI) is a design pattern that allows you to decouple the creation and management of object dependencies from the objects that depend on them. Instead of directly creating dependencies, objects receive their dependencies from an external source. For example, through the constructor, method parameters, or properties."
      },
      {
        "question": "Why is dependency injection useful?",
        "answer": "1. Promotes loose coupling between components, making the code more modular and testable. 2. Allows for easy substitution of implementations, enabling flexibility and adaptability. 3. Facilitates the use of abstractions, which can improve the system's overall design. 4. Simplifies the management of object lifetime and resource allocation."
      },
      {
        "question": "What are cohesion and coupling, and what do they mean?",
        "answer": "COHESION refers to the degree to which the elements inside a module (e.g., a class or a function) belong together. High cohesion means that the elements within a module are strongly related and work together to achieve a specific purpose. Low cohesion indicates that the elements within a module are loosely related or unrelated, making the module harder to understand and maintain. COUPLING refers to the degree of interdependence between modules. Low coupling means that modules have minimal dependencies on each other, making the system more flexible and easier to modify. High coupling indicates that modules have strong dependencies, which can make the system more rigid and harder to change."
      },
      {
        "question": "What design patterns do you know? Explain the essence of the ones you mentioned.",
        "answer": "1. SINGLETON ensures a class has only one instance and provides a global point of access to it. Useful for managing global state or resources. 2. FACTORY defines an interface for creating objects but lets subclasses decide which class to instantiate. Helpful for creating objects without exposing the creation logic. 3. ADAPTER converts the interface of a class into another interface the client expects. Allows classes with incompatible interfaces to work together. 4. OBSERVER defines a one-to-many dependency between objects. So that when one object changes state, all its dependents are notified and updated automatically. Useful for implementing event-driven architectures. 5. STRATEGY defines a family of algorithms, encapsulates each one, and makes them interchangeable. Allows the algorithm used by a class to be selected at runtime."
      },
      {
        "question": "What is loosely-coupled code? How is it better than tightly-coupled code? How would you achieve loose coupling?",
        "answer": "Loosely-coupled code has minimal dependencies between components, enabling independent development and evolution. It's better than tightly-coupled code, which is harder to maintain and change. Achieve loose coupling through abstractions (interfaces), dependency injection, event-driven communication, and modular design."
      },
      {
        "question": "Does using static classes increase or decrease code coupling?",
        "answer": "Static classes can increase code coupling by introducing global states and dependencies across the codebase. Static classes are best used judiciously for utility classes or when truly required."
      },
      {
        "question": "How can you measure code performance? Does the act of measuring affect performance?",
        "answer": "Code performance can be measured using profiling tools, benchmarking frameworks, and performance counters. The act of measuring can affect performance due to instrumentation overhead."
      },
      {
        "question": "How can you tell when a piece of code is consuming a lot of memory or running slowly? What can be a bottleneck in different cases? What are ways to reduce memory usage and memory traffic?",
        "answer": "You can use profiling tools like memory and CPU profilers to identify code that consumes a lot of memory or runs slowly. Potential bottlenecks could be CPU-bound tasks, I/O-bound tasks, or memory-intensive operations. You can optimize data structures, limit allocations, and use techniques like memory pooling to reduce memory usage. To reduce memory traffic, you can improve cache utilization, minimize data copying, and optimize memory access patterns."
      },
      {
        "question": "Tell me about the REST Maturity Model.",
        "answer": "The REST Maturity Model is a framework for evaluating the level of “RESTfulness” in an API. It has four levels: Level 0 (the most basic), Level 1 (resource-oriented), Level 2 (HTTP verbs), and Level 3 (hypermedia controls)."
      },
      {
        "question": "What is marshaling?",
        "answer": "Marshaling is the process of converting an object's internal representation into a format that can be transmitted, stored, or read from a stream."
      },
      {
        "question": "How do you enable CORS in ASP.NET Core?",
        "answer": "In ASP.NET Core, you can enable CORS (Cross-Origin Resource Sharing) by configuring the CorsOptions in the Startup.cs file. It allows you to specify which origins, headers, and HTTP methods are allowed to access your API."
      },
      {
        "question": "What data structures have you implemented yourself for the .NET platform? How did they differ from the standard implementations?",
        "answer": "I have implemented several custom data structures for the .NET platform, including a custom Linked List and a Priority Queue. These implementations often differ from the standard .NET collections regarding performance characteristics, memory usage, or specialized functionality."
      },
      {
        "question": "How do interfaces differ from abstract classes? In what cases would you use one or the other?",
        "answer": "The main difference between interfaces and abstract classes is that interfaces can only define method signatures, properties, events, and indexers. At the same time, abstract classes can include method implementations, fields, and constructors. Interfaces are generally used to define contracts or APIs, while abstract classes are used to provide a base implementation for related types."
      },
      {
        "question": "When and which databases are better to use?",
        "answer": "The choice of database depends on factors like the data model, scalability requirements, performance needs, and the type of queries the application will perform. RDBMS are well-suited for applications with structured data and complex relationships. In contrast, NoSQL databases excel at handling unstructured data and high-volume, high-velocity workloads."
      },
      {
        "question": "What is denormalization?",
        "answer": "Denormalization is the process of intentionally duplicating data in a database to improve query performance."
      },
      {
        "question": "How are the ACID principles implemented in popular RDBMSs (SQL Server, PostgreSQL, etc.)?",
        "answer": "ACID (Atomicity, Consistency, Isolation, Durability) principles are implemented in RDBMS through features like transaction management, locking mechanisms, and logging/recovery processes."
      },
      {
        "question": "Have you ever optimized a database query? If so, how?",
        "answer": "Database queries can be optimized by analyzing execution plans, adding appropriate indexes, and denormalizing data structures."
      },
      {
        "question": "What problem do microservices solve?",
        "answer": "Microservices solve the complexity problem in large, monolithic applications by breaking them down into smaller, independent services that can be developed, deployed, and scaled separately."
      },
      {
        "question": "What are the ways microservices can communicate?",
        "answer": "Microservices can communicate using various inter-service communication patterns, such as synchronous HTTP/REST, asynchronous messaging (e.g., queues, event buses), or a hybrid approach."
      },
      {
        "question": "How would you debug a system composed of multiple microservices to trace the full request processing path?",
        "answer": "To debug a microservices-based system, you can use distributed tracing tools like Jaeger or Zipkin, which allow you to trace the full request processing path across multiple services."
      },
      {
        "question": "What are message brokers?",
        "answer": "Message brokers like RabbitMQ, Apache Kafka, or Azure Service Bus facilitate asynchronous communication between microservices."
      },
      {
        "question": "What queue-related tools are you familiar with (both in .NET and standalone products), and which would you choose and why?",
        "answer": "I'm familiar with various queue-related tools, such as RabbitMQ, Apache Kafka, and Azure Service Bus. The choice would depend on factors like the application's specific requirements, the team's familiarity with the technology, and the overall ecosystem."
      },
      {
        "question": "Why is the ThreadPool needed? Describe the mechanics: how a thread is allocated and returned to the ThreadPool.",
        "answer": "The ThreadPool provides an efficient way to manage and reuse threads for asynchronous/parallel tasks, avoiding the overhead of manual thread creation/termination. When a task is requested, the ThreadPool allocates an available thread from its queue; if none is available and under the max limit, it creates a new thread. After executing the task, the thread is returned to the queue for reuse until an idle timeout, then terminated."
      },
      {
        "question": "How do ORMs (Entity Framework or Entity Framework Core) translate C# code into database query language? What is used for this?",
        "answer": "ORMs like Entity Framework and Entity Framework Core use a component called LINQ to Entities (LINQ to EF) to translate C# LINQ queries into database query language (SQL). LINQ to Entities acts as a query provider, taking the LINQ query expression and translating it into an expression tree. This expression tree is then processed by the Entity Framework query pipeline, which generates the corresponding SQL query to be executed against the database. The translation process involves analyzing the expression tree, applying optimization rules, and mapping the LINQ constructs to their SQL equivalents."
      },
      {
        "question": "What is an index in a database?",
        "answer": "An index in a database is a data structure that stores a subset of data from a table to improve the speed of data retrieval operations. It works similarly to an index in a book, pointing to the location of specific data values within the table. Indexes are typically created on one or more columns of a table."
      },
      {
        "question": "When should you use indexes?",
        "answer": "Indexes should be used when: 1. Frequent queries involve searching, sorting, or retrieving data based on one or more columns. 2. You need to enforce uniqueness constraints or foreign key relationships. 3. You want to improve the performance of join operations between tables."
      },
      {
        "question": "What are the pros and cons of using indexes?",
        "answer": "PROS: 1. Faster data retrieval for queries involving indexed columns. 2. Improved query performance, especially for large tables. 3. Enforced uniqueness and integrity constraints. CONS: 1. Additional storage space is required for the index data structures. 2. Due to index maintenance, increased overhead for data modification operations (inserts, updates, deletes). 3. Potential for index fragmentation over time, leading to performance degradation."
      },
      {
        "question": "What types of indexes exist? How do they differ?",
        "answer": "CLUSTERED INDEX: Physically reorders the data rows in the table based on the index key values. Only one clustered index is allowed per table. NON-CLUSTERED INDEX: Stores the index keys and pointers to the corresponding data rows, keeping the data rows' physical order unchanged. Multiple non-clustered indexes are allowed per table. UNIQUE INDEX: Ensures that the indexed column(s) have unique values across all rows in the table. COMPOSITE INDEX: Indexes multiple columns within the same index structure. COVERING INDEX: Includes all the columns required for a query, eliminating the need to access the data rows directly. FULL-TEXT INDEX: Optimized for text-based searches, allowing for pattern matching and linguistic analysis. SPATIAL INDEX: Used for efficiently querying and retrieving spatial data, such as geographic coordinates."
      },
      {
        "question": "What is ACID?",
        "answer": "ACID is an acronym that represents four essential properties of database transactions: ATOMICITY: A transaction is an indivisible unit of work; either all of its operations are completed successfully or none are executed. CONSISTENCY: A transaction must leave the database in a valid state, following all defined rules, constraints, and integrity constraints. ISOLATION: Concurrent transactions must execute independently and not interfere with each other, even if they operate on the same data. DURABILITY: Once a transaction is committed, its effects must persist and remain permanent, even in the event of system failure or power outage."
      },
      {
        "question": "What is a query execution plan in MS SQL?",
        "answer": "A query execution plan in Microsoft SQL Server is a strategy that the database engine generates to execute a given SQL query. It represents the sequence of operations and algorithms the query optimizer chooses to retrieve the requested data efficiently. The query execution plan provides insights into the following: 1. The order of operations (e.g., table scans, index seeks, joins, sorts, aggregations). 2. The specific indexes and data structures used. 3. The estimated cost and resource utilization (CPU, memory, I/O). 4. The data flow and data access patterns."
      },
      {
        "question": "What can DBAs and developer achieve by analyzing the query execution plan?",
        "answer": "1. Identify potential performance bottlenecks or inefficient operations. 2. Optimize queries by modifying indexing strategies or query structures. 3. Understand the reasoning behind the query optimizer's choices. 4. Diagnose and troubleshoot slow-performing queries."
      },
      {
        "question": "If a query is taking a long time to execute, what methods can be used to diagnose the problem?",
        "answer": "1. Analyze the Query Execution Plan: Examine the query execution plan to identify potential bottlenecks, such as inefficient index usage, costly operations (e.g., table scans), or suboptimal join strategies. 2. Check Indexing Strategy: Verify if appropriate indexes exist for the columns involved in the query predicates, joins, and sorting operations. If necessary, create new indexes or modify existing ones. 3. Review Query Structure: Analyze the query structure and consider rewriting it using more efficient constructs, such as subqueries, derived tables, or common table expressions (CTEs). 4. Check Statistics: Ensure the database statistics are up-to-date, as outdated statistics can lead to suboptimal query plans. 5. Monitor Resource Usage: Use monitoring tools to check for resource contention or bottlenecks, such as high CPU usage, memory pressure, or disk I/O issues. 6. Partition Data: If the query involves large tables, consider partitioning the data to improve query performance and enable parallel execution. 7. Optimize Database Configuration: Review database configuration settings, such as memory allocation, cost thresholds, and query optimization levels, and adjust them as needed. 8. Implement Caching: If the query involves repetitive or static data, consider implementing caching mechanisms to avoid redundant database queries. 9. Parallelize Queries: Investigate if the query can be parallelized or if the database supports parallel query execution to leverage multiple CPU cores. 10. Denormalize Data: In some cases, denormalizing data by introducing redundancy can improve query performance, but it should be carefully weighed against potential data integrity and maintenance concerns."
      },
      {
        "question": "What is reflection?",
        "answer": "Reflection is a mechanism in .NET that allows code to inspect and interact with itself at runtime. This mechanism provides a way to dynamically discover and manipulate types, fields, methods, properties, and other metadata of loaded assemblies during program execution."
      },
      {
        "question": "What is an immutable object? What are the benefits of using immutable objects?",
        "answer": "An immutable object is an object whose state cannot be modified after creation. Once an immutable object is instantiated, its properties and fields remain constant throughout its lifetime. Benefits of using immutable objects include: THREAD SAFETY - Immutable objects are inherently thread-safe, as their state cannot be modified concurrently. SIMPLICITY - Immutable objects are simpler to reason about and debug, as their behavior is predictable and deterministic. CACHING - Immutable objects can be safely cached, as their state never change"
      },
      {
        "question": "When should you use StringBuilder, and when should you use string?",
        "answer": "In general, you should use StringBuilder when performing multiple string operations (concatenations, insertions, modifications, etc.), especially in loops or performance-critical code. string is immutable, meaning that any operation that modifies a string creates a new string object, which can lead to performance issues and increased memory usage."
      },
      {
        "question": "How does StringBuilder work?",
        "answer": "StringBuilder is a mutable object that provides a more efficient way to build strings dynamically. It works by pre-allocating a buffer in memory and allowing you to modify the contents of that buffer directly without creating new string objects for each operation. This approach is more efficient, especially when dealing with large strings or performing many string operations. Here's a simplified overview of how StringBuilder works: 1. StringBuilder allocates an initial buffer in memory to store characters. 2. As you append, insert, or modify characters, StringBuilder updates the buffer directly without creating new string objects. 3. If the buffer becomes too small to hold the new characters, StringBuilder automatically resizes the buffer to accommodate the additional characters. 4. When you need the final string, you can call the ToString() method, which creates a new string instance from the contents of the buffer."
      },
      {
        "question": "What design patterns for distributed systems do you know?",
        "answer": "1. Microservices: Organizes an application as a collection of loosely coupled, independently deployable services. 2. API Gateway: Serves as a single entry point for clients to access the underlying microservices. 3. Circuit Breaker: Prevents cascading failures in distributed systems by stopping calls to a failing service. 4. Event-Driven Architecture: Uses an event bus or message broker to decouple the components of a distributed system. 5.CQRS (Command Query Responsibility Segregation): Separates the read and write operations responsibilities, often used in event-driven architectures."
      },
      {
        "question": "What are the principles of a Message Bus?",
        "answer": "1. Loose Coupling: The components of the system are decoupled, communicating asynchronously through the message bus. 2. Scalability: The message bus can handle increasing message loads by adding more message brokers or consumers. 3. Reliability: To ensure reliable delivery, the message bus provides features like message persistence, retries, and dead-letter queues."
      },
      {
        "question": "Why can duplicates occur in queues?",
        "answer": "Duplicates can occur in queues for various reasons, such as network failures, process restarts, or message redelivery. To handle this, consumers should be designed to be idempotent, meaning they can safely process the same message multiple times."
      },
      {
        "question": "Explain how asynchronous methods work. How does asynchronicity differ from parallelism?",
        "answer": "Asynchronicity enables a single thread to be more productive by allowing it to switch between multiple tasks. In contrast, parallelism utilizes multiple threads to work on tasks concurrently. Both approaches can be used to improve the performance and scalability of applications, but they address different types of problems. The key difference between asynchronicity and parallelism is: ASYNCHRONICITY allows a single thread to perform other work while waiting for a long-running operation to complete without blocking the main thread. PARALLELISM involves concurrently executing multiple threads, each working on a different task. Parallelism is useful for CPU-bound tasks that can be divided into smaller, independent subtasks. However, it requires more complex synchronization and resource management compared to asynchronicity."
      },
      {
        "question": "What is the difference between DataSet.Clone and DataSet.Copy?",
        "answer": "DataSet.Clone copies only the structure of the DataSet, including all DataTable relations, schemas, and constraints. It does not copy any data. DataSet.Copy is a deep copy of a DataSet. It duplicates both its structure and data."
      },
      {
        "question": "What is the difference between DLL and EXE?",
        "answer": ".EXE files are single outbound files that cannot be shared with other applications. DLL files are multiple inbound files that are shareable."
      },
      {
        "question": "What is Serialization?",
        "answer": "Serialisation is typically the process of converting the state of an object into a form. We can transport the form. Deserialisation converts a stream into an object. It allows data to be stored and transferred."
      },
      {
        "question": "What is Object Pooling?",
        "answer": "Object pooling allows using limited resources with the help of software constructs. We can store objects, ready-to-use connections, and threads in a pool in memory so we can use them as and when required. We can pull a new object from the pool and allocate it for a request. Overall, pooling improves performance and scalability. "
      },
      {
        "question": "What are Tuples?",
        "answer": "A tuple is essentially a data structure. It contains a sequence of elements of different data types. Tuples are data structures that support holding object properties. They avoid creating separate types to hold object properties."
      },
      {
        "question": "What are the advantages of Web Services?",
        "answer": "1. Web services are simple to build. They support multiple platforms. 2. A web service can extend its interface. It can add new methods without affecting the client's operations. 3. It is stateless and firewall-friendly."
      },
      {
        "question": "What is a .NET web service?",
        "answer": "We can locate a web service in .NET on a web server. A .NET web service uses standard web protocols to interact with other network applications. The protocols can be HTTP and SOAP. A web service that performs asynchronous communications for XML applications. The applications operate over a .NET communications framework. Also, the .NET web service is a component that helps publish an application's function on the web, making it available to the public."
      },
      {
        "question": "What are the different parts of an Assembly?",
        "answer": "MANIFEST: It is also known as the assembly metadata. It has details of assembly versions. TYPE METADATA: It has the binary information of a program. MSIL: It is known as the Microsoft Intermediate Language code. RESOURCES: It has a list of related files."
      },
      {
        "question": "What is the difference between managed and unmanaged codes?",
        "answer": "MANAGED CODES: 1. They run inside a runtime environment. 2. We need to install the .NET framework for execution. 3. They provide automatic memory management. 4. It provides security to applications. 5. It doesn’t allow a memory buffer overflow. UNMANAGED CODES: 1. They run directly on hardware. 2. We don't need to install the .NET framework for execution. 3. It needs manual memory and pointers management. 4. It doesn't provide security to applications. 5. It will enable memory buffer overflow."
      },
      {
        "question": "What is the session object?",
        "answer": "A Session object stores information and variables. It retains them throughout the session."
      },
      {
        "question": "What is the application object?",
        "answer": "An application object shares information with all application users. We can put together a set of ASP files to perform a specific purpose."
      },
      {
        "question": "Differentiate between a Debug build and a Release build?",
        "answer": "Debug builds don't allow the accurate setting of breakpoints. They contain debugging symbols. The code built-in `Release` build is optimised for speed or size without any debug data."
      },
      {
        "question": "What is the difference between trace class and debug class?",
        "answer": "A call to the Debug class is included in Debug mode only. It is used during the application development. On the other hand, a call to the Trace class can be included in Debug and Release mode. It is used during the application deployment."
      },
      {
        "question": "What are the divisions of the Memory Heap?",
        "answer": "GENERATION 0: It is Used to store short-lived objects. Frequent Garbage Collection happens in this Generation. GENERATION 1: It is used for medium-lived objects. GENERATION 2: It is used for long-lived objects."
      },
      {
        "question": "What is a Hashtable?",
        "answer": "The Hashtable class is basically a collection. It stores key-value pairs and organises them based on each key's hash code, which is used to access elements in the collection."
      },
      {
        "question": "What is MIME?",
        "answer": "MIME stands for Multipurpose Internet Mail Extension. It is a supplementary protocol that sends non-ASCII data through SMTP and facilitates the exchange of data files on the Internet."
      },
      {
        "question": "What is Object-Role Modeling (ORM)?",
        "answer": "Object-Role Modeling (ORM) is a powerful method for designing and querying information systems at the conceptual level. It is an easy and understandable description of the application for non-technical users."
      },
      {
        "question": "What are the events and delegates?",
        "answer": "Events are stored as public class members. On the other hand, delegates are stored as private class members. Delegates are also passed as parameters."
      },
      {
        "question": "What is an Interface?",
        "answer": "An interface is a declaration for a set of class members. It is a reference type that contains only abstract members such as Events, Methods, Properties, etc."
      },
      {
        "question": "Does .NET support multiple inheritances?",
        "answer": "No, .NET supports only single inheritance. In .NET, a class can inherit only from a single class."
      },
      {
        "question": "What are the two types of Polymorphism?",
        "answer": "1. Static or compile-time polymorphism 2. Dynamic or runtime polymorphism"
      },
      {
        "question": "What is Polymorphism?",
        "answer": "Polymorphism refers to one interface with multiple functions. It means that the same method or property can perform different actions depending on the run-time type of the instance that invokes it."
      },
      {
        "question": "Define Method Overriding?",
        "answer": "Method Overriding is a process that allows using the same name, return type, argument, and invoking the same functions from another class (base class) in the derived class."
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  }
  